<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Custom in the Making | Niccolò Ridi</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>(function(){var t=localStorage.getItem('theme');if(!t)t='dark';if(t==='dark')document.documentElement.classList.add('dark-mode');})()</script>
    <style>
        :root {
            --primary-color: #1a1a1a;
            --secondary-color: #555555;
            --text-color: #333333;
            --border-color: #e0e0e0;
            --background-color: #ffffff;
            --header-bg: #ffffff;
            --accent-color: #1a1a1a;
            --subtle-border: #f0f0f0;
            --card-bg: #ffffff;
            --pullquote-border: #ccc;
            --pullquote-bg: #f9f9f9;
            --stat-color: #c0392b;
            --highlight-color: #c0392b;
            --heat-low: #fff5eb;
            --heat-high: #b30000;
            --topo-complete: #95a5a6;
            --topo-regional: #e67e22;
            --topo-smallworld: #27ae60;
            --topo-scalefree: #3498db;
            --topo-power: #8e44ad;
            --bar-primary: #3498db;
            --bar-secondary: #e67e22;
            --bar-tertiary: #27ae60;
            --bar-danger: #c0392b;
        }

        .dark-mode {
            --primary-color: #e8eaed;
            --secondary-color: #9aa0ab;
            --text-color: #d0d0d0;
            --border-color: #333333;
            --background-color: #121212;
            --header-bg: #1a1a1a;
            --accent-color: #d4a574;
            --subtle-border: #2a2a2a;
            --card-bg: #1e1e1e;
            --pullquote-border: #444;
            --pullquote-bg: #1a1a1a;
            --stat-color: #d4a574;
            --highlight-color: #d4a574;
            --heat-low: #1a1a1a;
            --heat-high: #d4a574;
            --topo-complete: #7f8c8d;
            --topo-regional: #eb984e;
            --topo-smallworld: #2ecc71;
            --topo-scalefree: #5dade2;
            --topo-power: #a569bd;
            --bar-primary: #5dade2;
            --bar-secondary: #eb984e;
            --bar-tertiary: #2ecc71;
            --bar-danger: #d4a574;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            line-height: 1.8;
            background-color: var(--background-color);
            color: var(--text-color);
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        main { flex: 1; }
        body.nav-open { overflow: hidden; }

        a { color: var(--primary-color); text-decoration: none; font-weight: bold; }
        a:hover { color: var(--secondary-color); }
        .dark-mode a { color: var(--accent-color); }
        .dark-mode a:hover { color: #e8c49a; }
        .dark-mode .main-nav a { color: var(--primary-color); }
        .dark-mode .main-nav .ext-link { color: var(--secondary-color); }
        .dark-mode .main-nav .ext-link:hover { color: var(--primary-color); }
        .dark-mode .main-footer a { color: var(--accent-color); }
        .dark-mode .main-header { box-shadow: 0 2px 10px rgba(0,0,0,0.3); }

        /* Theme toggle */
        .theme-toggle {
            background: none;
            border: 1px solid var(--border-color);
            border-radius: 2rem;
            padding: 4px 12px;
            cursor: pointer;
            font-size: 12px;
            color: var(--secondary-color);
            display: flex;
            align-items: center;
            gap: 5px;
            transition: all 0.2s ease;
            flex-shrink: 0;
            font-family: inherit;
        }
        .theme-toggle:hover { color: var(--primary-color); border-color: var(--primary-color); }

        /* Header */
        .main-header {
            background: var(--header-bg);
            padding: 1.5rem 0;
            position: sticky;
            top: 0;
            z-index: 1000;
            box-shadow: 0 2px 10px rgba(0,0,0,0.07);
        }

        .main-header .container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 2rem;
            gap: 1rem;
            max-width: 960px;
            margin: auto;
        }

        .main-header .logo {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--primary-color);
            z-index: 1001;
        }

        .main-nav ul { list-style: none; display: flex; gap: 2rem; }
        .main-nav a { color: var(--primary-color); font-weight: normal; position: relative; padding: 0.5rem 0; }
        .main-nav a::after { content: ''; position: absolute; bottom: 0; left: 0; width: 0; height: 2px; background-color: var(--primary-color); transition: width 0.3s ease; }
        .main-nav a:hover::after { width: 100%; }
        .nav-sep { width: 1px; background: var(--border-color); align-self: stretch; margin: 0 0.2rem; }
        .main-nav .ext-link { color: var(--secondary-color); font-size: 0.85rem; }
        .main-nav .ext-link:hover { color: var(--primary-color); }

        .hamburger-menu { display: none; background: none; border: none; cursor: pointer; padding: 10px; z-index: 1001; }
        .hamburger-menu .line { display: block; width: 25px; height: 2px; background-color: var(--primary-color); margin: 5px 0; transition: transform 0.3s ease, opacity 0.3s ease; }

        /* Essay layout */
        .essay-container {
            max-width: 720px;
            margin: 0 auto;
            padding: 3rem 2rem 4rem;
        }

        .essay-header {
            margin-bottom: 3rem;
            padding-bottom: 2rem;
            border-bottom: 1px solid var(--border-color);
        }

        .essay-header h1 {
            font-size: 2.4rem;
            font-weight: 700;
            color: var(--primary-color);
            line-height: 1.2;
            margin-bottom: 1rem;
        }

        .essay-meta {
            font-size: 0.9rem;
            color: var(--secondary-color);
            line-height: 1.6;
        }

        .essay-meta .authors { font-weight: 600; color: var(--text-color); }

        .essay-body h2 {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--primary-color);
            margin: 3rem 0 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid var(--border-color);
        }

        .essay-body h3 {
            font-size: 1.15rem;
            font-weight: 600;
            color: var(--primary-color);
            margin: 2rem 0 0.8rem;
        }

        .essay-body p {
            margin-bottom: 1.3rem;
            max-width: none;
            font-size: 1.02rem;
        }

        .essay-body p.lead {
            font-size: 1.15rem;
            color: var(--secondary-color);
            line-height: 1.7;
        }

        /* Stat callouts */
        .stat-row {
            display: flex;
            gap: 1.5rem;
            margin: 2rem 0;
            flex-wrap: wrap;
        }

        .stat-box {
            flex: 1;
            min-width: 120px;
            text-align: center;
            padding: 1.2rem 1rem;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: var(--card-bg);
        }

        .stat-box .num {
            font-size: 2rem;
            font-weight: 700;
            color: var(--stat-color);
            display: block;
            line-height: 1.2;
        }

        .stat-box .label {
            font-size: 0.78rem;
            color: var(--secondary-color);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-top: 0.3rem;
            display: block;
        }

        /* Pullquote */
        .pullquote {
            border-left: 3px solid var(--pullquote-border);
            padding: 1.2rem 1.5rem;
            margin: 2rem 0;
            background: var(--pullquote-bg);
            border-radius: 0 6px 6px 0;
            font-style: italic;
            color: var(--secondary-color);
            font-size: 0.95rem;
        }

        .pullquote cite {
            display: block;
            margin-top: 0.5rem;
            font-style: normal;
            font-size: 0.82rem;
            color: var(--secondary-color);
        }

        /* Viz containers */
        .viz-block {
            margin: 2.5rem -2rem;
            padding: 0;
            position: relative;
        }

        .viz-block svg {
            width: 100%;
            display: block;
            background: transparent;
        }

        .viz-caption {
            font-size: 0.8rem;
            color: var(--secondary-color);
            text-align: center;
            margin-top: 0.5rem;
            font-style: italic;
        }

        .viz-tooltip {
            position: absolute;
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 6px 10px;
            font-size: 0.78rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.15s;
            z-index: 10;
            color: var(--text-color);
            max-width: 250px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }

        /* Legend */
        .viz-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 0.6rem 1.2rem;
            justify-content: center;
            margin-top: 0.8rem;
            font-size: 0.75rem;
            color: var(--secondary-color);
        }

        .viz-legend span {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .viz-legend .swatch {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
        }

        /* Scroll reveal */
        .viz-reveal {
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.8s ease-out, transform 0.8s ease-out;
        }

        .viz-reveal.visible {
            opacity: 1;
            transform: translateY(0);
        }

        /* Bar chart axes */
        .bar-label { font-size: 11px; fill: var(--secondary-color); }
        .bar-axis text { font-size: 10px; fill: var(--secondary-color); }
        .bar-axis line, .bar-axis path { stroke: var(--border-color); }

        /* Heatmap cells */
        .heat-cell { cursor: crosshair; }
        .heat-cell:hover { stroke: var(--primary-color); stroke-width: 2; }

        /* Mini network containers — Olympic circles: 3 over 2 */
        .topo-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 1rem;
            margin: 1.5rem 0;
        }
        .topo-card:nth-child(1) { grid-column: 1 / 3; }
        .topo-card:nth-child(2) { grid-column: 3 / 5; }
        .topo-card:nth-child(3) { grid-column: 5 / 7; }
        .topo-card:nth-child(4) { grid-column: 2 / 4; }
        .topo-card:nth-child(5) { grid-column: 4 / 6; }
        .topo-card {
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: var(--card-bg);
            padding: 0.8rem;
            text-align: center;
        }
        .topo-card .topo-label {
            font-size: 0.82rem;
            font-weight: 600;
            color: var(--primary-color);
            margin-bottom: 0.3rem;
        }
        .topo-card .topo-rate {
            font-size: 1.6rem;
            font-weight: 700;
            color: var(--stat-color);
            line-height: 1.1;
        }
        .topo-card .topo-sub {
            font-size: 0.7rem;
            color: var(--secondary-color);
            text-transform: uppercase;
            letter-spacing: 0.04em;
        }
        .topo-card svg {
            display: block;
            margin: 0.5rem auto 0.3rem;
        }

        /* Comparison bars */
        .compare-row {
            display: flex;
            gap: 1rem;
            margin: 1.5rem 0;
            flex-wrap: wrap;
        }
        .compare-item {
            flex: 1;
            min-width: 140px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: var(--card-bg);
            padding: 1rem;
            text-align: center;
        }
        .compare-item .compare-label {
            font-size: 0.78rem;
            color: var(--secondary-color);
            margin-bottom: 0.3rem;
            text-transform: uppercase;
            letter-spacing: 0.04em;
        }
        .compare-item .compare-val {
            font-size: 2.2rem;
            font-weight: 700;
            line-height: 1.1;
        }
        .compare-item .compare-sub {
            font-size: 0.75rem;
            color: var(--secondary-color);
            margin-top: 0.2rem;
        }
        .val-high { color: var(--bar-tertiary); }
        .val-low { color: var(--bar-danger); }
        .val-mid { color: var(--stat-color); }

        /* Footer */
        .main-footer { padding: 1.5rem 2rem; text-align: center; font-size: 0.9rem; color: var(--secondary-color); }
        .main-footer a { color: var(--primary-color); }
        .main-footer p { max-width: none; margin-bottom: 0; }

        /* Back link */
        .back-link {
            display: inline-block;
            margin-bottom: 1.5rem;
            font-size: 0.85rem;
            color: var(--secondary-color);
            font-weight: normal;
        }
        .back-link:hover { color: var(--primary-color); }
        .dark-mode .back-link { color: var(--secondary-color); }
        .dark-mode .back-link:hover { color: var(--accent-color); }

        /* Responsive */
        @media (max-width: 768px) {
            .essay-header h1 { font-size: 1.8rem; }
            .essay-body h2 { font-size: 1.3rem; }
            .essay-container { padding: 2rem 1.2rem 3rem; }
            .viz-block { margin: 2rem -0.5rem; }
            .stat-row { gap: 0.8rem; }
            .stat-box .num { font-size: 1.5rem; }
            .stat-box { min-width: 100px; padding: 1rem 0.6rem; }
            .topo-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 0.6rem;
            }
            .topo-card:nth-child(1),
            .topo-card:nth-child(2),
            .topo-card:nth-child(3),
            .topo-card:nth-child(4),
            .topo-card:nth-child(5) { grid-column: auto; }
            .topo-card:nth-child(5) { grid-column: 1 / -1; max-width: 50%; margin: 0 auto; }

            .hamburger-menu { display: block; }
            .main-nav {
                position: fixed; top: 0; left: 0;
                width: 100%; height: 100vh;
                background-color: var(--background-color);
                display: flex; justify-content: center; align-items: center;
                transform: translateX(100%);
                transition: transform 0.4s cubic-bezier(0.77, 0, 0.175, 1);
            }
            body.nav-open .main-nav { transform: translateX(0); }
            .main-nav ul { flex-direction: column; gap: 2rem; text-align: center; }
            .main-nav a { font-size: 1.5rem; }
            .main-nav a::after { display: none; }
            body.nav-open .hamburger-menu .line-1 { transform: rotate(45deg) translate(5px, 5px); }
            body.nav-open .hamburger-menu .line-2 { opacity: 0; }
            body.nav-open .hamburger-menu .line-3 { transform: rotate(-45deg) translate(5px, -5px); }
        }
    </style>
</head>
<body>

    <header class="main-header">
        <div class="container">
            <a href="index.html" class="logo">Niccolò Ridi</a>
            <nav class="main-nav">
                <ul>
                    <li><a href="profile.html">Profile</a></li>
                    <li><a href="practice.html">Practice</a></li>
                    <li><a href="research.html">Research</a></li>
                    <li><a href="data.html">Data</a></li>
                    <li class="nav-sep"></li>
                    <li><a href="https://www.linkedin.com/in/niccoloridi/" target="_blank" class="ext-link">LinkedIn</a></li>
                    <li><a href="https://scholar.google.com/citations?user=cxXS2JIAAAAJ" target="_blank" class="ext-link">Scholar</a></li>
                    <li><a href="https://papers.ssrn.com/sol3/cf_dev/AbsByAuth.cfm?per_id=2290991" target="_blank" class="ext-link">SSRN</a></li>
                    <li><a href="https://www.kcl.ac.uk/people/niccolo-ridi" target="_blank" class="ext-link">KCL</a></li>
                </ul>
            </nav>
            <button class="theme-toggle" onclick="toggleTheme()" title="Switch theme"><span id="theme-icon">◑</span> <span id="theme-label">Light</span></button>
            <button class="hamburger-menu" aria-label="Open navigation menu">
                <span class="line line-1"></span>
                <span class="line line-2"></span>
                <span class="line line-3"></span>
            </button>
        </div>
    </header>

    <main>
        <article class="essay-container">

            <a href="data.html" class="back-link">&larr; Back to Data</a>

            <header class="essay-header">
                <h1>Custom in the Making</h1>
                <div class="essay-meta">
                    <span class="authors">Niccolò Ridi</span><br>
                    An Agent-Based Model of Customary International Law Formation (2026)
                </div>
            </header>

            <div class="essay-body">

                <p class="lead">How does customary international law form? The ILC's Draft Conclusions describe what custom <em>requires</em> &ndash; general practice accepted as law &ndash; but not how scattered state behaviours crystallise into binding obligation. The dominant account is static, taxonomic, almost archaeological: lawyers sift through evidence of practice and <em>opinio juris</em> to determine whether a norm <em>exists</em>. The process by which it comes to exist is left to hand-waving about "gradual emergence."</p>

                <p>This Article tries something different. It builds an agent-based model &ndash; a computational simulation &ndash; that treats CIL formation as a dynamic process with identifiable mechanisms. One hundred state agents, embedded in observation networks, make decisions about whether to engage in a practice, whether to publicly affirm its legality, and whether to update their beliefs. No central authority coordinates them. No legislature votes. Norms emerge &ndash; or fail to emerge &ndash; from the bottom up, through the accumulation of decentralised interactions.</p>

                <p>The exercise forces a kind of intellectual honesty that doctrinal analysis can avoid. What exactly does "representative" practice mean? How does <em>opinio juris</em> update &ndash; gradually or in jumps? When does a norm count as "established"? Building a simulation requires answering these questions with numerical precision. Ambiguities that doctrine tolerates become choices that the model must resolve.</p>

                <p>The payoff is a set of findings that challenge conventional wisdom in ways that purely doctrinal reasoning could not. The idealised "international community" turns out to be the worst environment for norm formation. Hypocrisy facilitates the emergence of genuine legal conviction. Treaties catalyse custom among non-parties. And the entire system operates near a critical phase boundary &ndash; borrowed from physics &ndash; where small structural factors tip outcomes between crystallisation and failure.</p>

                <div class="stat-row">
                    <div class="stat-box"><span class="num">100</span><span class="label">State agents</span></div>
                    <div class="stat-box"><span class="num">5</span><span class="label">Network topologies</span></div>
                    <div class="stat-box"><span class="num">33&ndash;58%</span><span class="label">Crystallisation range</span></div>
                    <div class="stat-box"><span class="num">6</span><span class="label">Experiments</span></div>
                </div>

                <h2>Why Simulate?</h2>

                <p>Agent-based modelling offers three advantages for studying CIL formation that no amount of case-law analysis can replicate. First, it captures <strong>emergence</strong>: the way macro-level legal order arises from micro-level state interactions without central coordination. Traditional doctrinal analysis treats CIL as a binary status &ndash; either a norm exists or it does not &ndash; rather than as a dynamic process with tipping points, feedback loops, and path dependence. Second, ABM permits <strong>systematic experimentation</strong>. Questions that cannot be answered through case studies &ndash; such as whether the persistent objector rule destabilises norm formation, or whether treaties crowd out or catalyse custom &ndash; can be tested by toggling mechanisms on and off across thousands of simulated runs. Third, the method forces <strong>theoretical precision</strong>. Translating doctrinal concepts into code requires specifying exactly what "widespread" means, how belief updates, and when a norm counts as established.</p>

                <p>The model operationalises the ILC's two-element test as computational thresholds: widespread practice (&ge;60% of states), representative across regions and power tiers, consistent over 10 timesteps, and accompanied by <em>opinio juris</em> (&ge;60% mean belief among non-treaty states). Each agent possesses heterogeneous attributes &ndash; power drawn from a Pareto distribution, intrinsic preference, conformity weight, inertia &ndash; and updates beliefs through an evidence signal combining observed practice, observed statements, and duration.</p>

                <h2>I. The Phase Boundary</h2>

                <p>Before testing specific mechanisms, the model requires calibration. A sensitivity analysis varied two key parameters &ndash; intrinsic preference mean (&mu;<sub>IP</sub>) and conformity weight mean (&mu;<sub>CW</sub>) &ndash; across 63 combinations. The results reveal a sharp <strong>phase transition</strong>: a narrow parameter band where crystallisation is uncertain and structural factors become decisive.</p>

                <p>When intrinsic preference is high (&mu;<sub>IP</sub> &ge; 0.40), crystallisation occurs in 100% of simulations regardless of conformity weight. When it is low (&mu;<sub>IP</sub> &le; 0.25), it never occurs. Between these extremes lies the <strong>boundary region</strong> where outcomes are probabilistic.</p>

                <!-- HEATMAP -->
                <div class="viz-block viz-reveal" id="viz-heatmap"></div>
                <p class="viz-caption">Figure 1: Crystallisation rate by intrinsic preference (&mu;<sub>IP</sub>) and conformity weight (&mu;<sub>CW</sub>). Each cell represents 8 simulation runs. Hover for details.</p>

                <p>At the boundary parameters (&mu;<sub>IP</sub> = 0.30, &mu;<sub>CW</sub> = 0.45), crystallisation occurs in approximately 50% of simulations &ndash; the region of maximum uncertainty. All subsequent experiments operate at or near this boundary, where structural factors have bite.</p>

                <h2>II. Observation Structure</h2>

                <p>Current doctrine implicitly assumes that state practice is observable by all &ndash; the "international community" monitors and responds to what states do. But observation in practice is structured: states attend more closely to neighbours, trading partners, and major powers. Does this structure matter?</p>

                <p>Five network topologies were compared, each representing a different assumption about how states observe one another. The results are counterintuitive: the idealised "international community" where all observe all equally &ndash; the <strong>complete network</strong> &ndash; performs worst.</p>

                <!-- NETWORK TOPOLOGY MINI-VIZ -->
                <div class="viz-block viz-reveal" id="viz-topologies"></div>
                <p class="viz-caption">Figure 2: Crystallisation rates across five observation structures. Each topology was run 100 times at boundary parameters. Mini-networks illustrate each structure.</p>

                <p>The mechanism is signal aggregation. On a complete network, each state's evidence signal averages across 99 equally weighted neighbours. Local momentum &ndash; a cluster of states beginning to practise and reinforce each other &ndash; is diluted by the global average. A European state developing conviction observes not just its practising neighbours but also the 80 non-practising states elsewhere, dampening the signal. Structured networks permit local cascades to build before encountering global resistance. <strong>Small-world networks</strong> perform best (58%) because bridging ties allow successful local cascades to jump between clusters without requiring universal diffusion first.</p>

                <p>This reveals observation as a <strong>hidden variable</strong> in CIL doctrine. Crystallisation rates vary by 25 percentage points depending solely on who observes whom &ndash; yet current doctrine says nothing about observation structure. The ILC's requirement that practice be "representative" (Conclusion 8) takes on new significance: representative practice may matter not only because it demonstrates breadth of acceptance, but because it ensures the practice is <em>visible</em> across different network segments, enabling the bridging dynamics that facilitate global crystallisation.</p>

                <!-- TOPOLOGY BAR CHART -->
                <div class="viz-block viz-reveal" id="viz-topo-bars"></div>
                <p class="viz-caption">Figure 3: Network topology comparison across five outcome measures. 100 runs per topology, boundary parameters.</p>

                <h2>III. The Bootstrapping Paradox</h2>

                <p>Can "cheap talk" &ndash; states publicly affirming legality while privately doubting it &ndash; bootstrap genuine belief? The model varied sincerity (the probability that public statements reflect private conviction) from 0.2 to 1.0. The results are paradoxical.</p>

                <div class="compare-row">
                    <div class="compare-item">
                        <div class="compare-label">Low sincerity (0.2)</div>
                        <div class="compare-val val-high">44%</div>
                        <div class="compare-sub">crystallisation rate</div>
                    </div>
                    <div class="compare-item">
                        <div class="compare-label">Full sincerity (1.0)</div>
                        <div class="compare-val val-low">6%</div>
                        <div class="compare-sub">crystallisation rate</div>
                    </div>
                </div>

                <p>Low sincerity <em>facilitates</em> norm formation. High sincerity <em>prevents</em> it. When states make strategic statements &ndash; affirming legality when practising, regardless of private belief &ndash; the inflated statement environment creates a feedback loop. Other states observe widespread affirmation, update their beliefs accordingly, and genuine conviction emerges. By the time crystallisation occurs, the cheap talk has produced the belief it initially lacked.</p>

                <!-- SINCERITY CHART -->
                <div class="viz-block viz-reveal" id="viz-sincerity"></div>
                <p class="viz-caption">Figure 4: Crystallisation rate and mean <em>opinio juris</em> by sincerity level. 50 runs per condition, boundary parameters.</p>

                <p>At full sincerity, states honestly report their doubts. The candid acknowledgment that practice lacks legal status prevents the feedback loop from gaining traction. And here is the deepest paradox: the 6% of norms that <em>do</em> form under full sincerity have the highest hollow practitioner rates (37.7%) &ndash; states practising without genuine conviction. The honest-communication condition produces the fewest and the <em>least genuine</em> customs.</p>

                <p>This finding resonates with constructivist accounts in international relations that emphasise the performative dimension of legal claims. States that "act as if" a norm exists may, through their performance, bring it into existence &ndash; not as pretense but as a self-fulfilling dynamic where the performance generates the reality it describes.</p>

                <div class="pullquote">
                    The ILC's Conclusion 3(2) requires that practice and <em>opinio juris</em> be "separately ascertained." But the process that generates custom requires a phase where statements outrun conviction. Demanding strict correspondence throughout the formation process would prevent custom from emerging in the first place. The two-element test describes the <em>endpoint</em> of a dynamic process, not constraints that must hold throughout.
                </div>

                <h2>IV. Speed, Stability, and the Consistency Requirement</h2>

                <p>Is there a trade-off between the speed of norm formation and the stability of the resulting norm? The model varied conformity weight while holding intrinsic preference at the boundary, then administered a "shock" &ndash; randomly forcing 30% of practising states to defect &ndash; to test whether crystallised norms survive.</p>

                <!-- SPEED-STABILITY CHART -->
                <div class="viz-block viz-reveal" id="viz-speed"></div>
                <p class="viz-caption">Figure 5: Speed-stability trade-off. Higher conformity weight produces faster crystallisation but also deeper conviction, making norms more resilient. 50 runs per condition.</p>

                <p>A clear pattern emerges: norms that form quickly under high conformity weight also build deeper <em>opinio juris</em>, making them <strong>more</strong> resilient to shocks. At low conformity weight (0.40), only 7 of 50 simulations crystallise, with mean time of 194 steps and 86% survival. Above 0.50, all crystallised norms survive the shock &ndash; faster formation correlates with greater stability, not less. The ILC's consistency requirement (Conclusion 8) functions as a quality filter: norms that maintain practice long enough to satisfy it have, by definition, built the deep conviction needed to persist.</p>

                <h2>V. Power and Structure at the Boundary</h2>

                <p>The remaining experiments test three structural mechanisms: the preferences of powerful states, the persistent objector rule, and the treaty channel. Each operates most dramatically at the boundary &ndash; where norms are contested and outcomes uncertain.</p>

                <h3>Power alignment</h3>
                <p>When the top 10% most powerful states support the practice, crystallisation jumps from 38% to <strong>80%</strong>. When they oppose it, crystallisation collapses to <strong>2%</strong>. The 78 percentage-point swing is the largest effect observed in any experiment. The mechanism operates through the observation channel: powerful states' practice and statements carry disproportionate weight in other states' evidence signals, shifting the informational environment for all 100 agents.</p>

                <p>This gives precision to the ILC's reference to "specially affected states." They matter not because their practice counts more toward a legal threshold but because it is <em>observed</em> more. The distinction is important: if specially affected states' practice counted more, a norm could crystallise over their objection if enough other states participated. But if their practice is <em>observed</em> more, their opposition can prevent crystallisation regardless of what others do &ndash; not by vetoing the legal standard but by shaping the informational environment in which beliefs form. The model's 2% rate means that even when 90% of states favour a practice, opposition by the top 10% can prevent its emergence as law.</p>

                <h3>Persistent objection</h3>
                <p>The persistent objector rule (ILC Conclusion 15) acts as a <strong>quality filter</strong>. At the boundary, objection devastates norm formation: crystallisation drops from 38% to 4%. But at favourable parameters, it produces only a modest drag (100% to 90%). The rule filters out fragile norms while permitting robust ones to bind all but the most committed dissenters.</p>

                <h3>Treaties</h3>
                <p>Introducing a treaty channel at the boundary increases crystallisation from 38% to <strong>100%</strong> &ndash; the largest facilitation effect observed in any experiment. The mechanism is indirect: treaty signatories are locked into consistent practice and affirmation, creating a stable bloc whose behaviour is no longer subject to stochastic fluctuation. The remaining ~37 non-signatories observe this elevated practice environment, and their <em>opinio juris</em> rises in response. Crucially, the crystallisation check excludes signatories' beliefs &ndash; it requires genuine customary conviction among non-parties. The treaty functions as a stepping stone, not a substitute: it does not replace customary obligation but creates the conditions under which customary obligation emerges among those not bound by the treaty.</p>

                <!-- STRUCTURAL FACTORS CHART -->
                <div class="viz-block viz-reveal" id="viz-structural"></div>
                <p class="viz-caption">Figure 6: Effect of structural mechanisms on crystallisation rate. Each mechanism tested at boundary parameters. Baseline (no mechanism) shown for comparison.</p>

                <h2>VI. The Phase Boundary Framework</h2>

                <p>The central claim is that CIL formation operates near a phase boundary. When preferences strongly favour a practice, norms crystallise reliably regardless of institutional design. When preferences strongly oppose it, nothing works. In the contested middle &ndash; where most interesting norms reside &ndash; small factors tip outcomes.</p>

                <div class="pullquote">
                    Network topology produces a 25 percentage-point swing in crystallisation (33% to 58%), but only at the boundary. Treaty channels increase crystallisation from 38% to 100% at the boundary, but have no effect where crystallisation already occurs. Objection devastates norm formation at the boundary (38% to 4%) but produces only modest drag at favourable parameters (100% to 90%). Power alignment swings crystallisation from 2% to 80%.
                </div>

                <p>The implication is that structural factors matter precisely where legal and political stakes are highest &ndash; for contested norms where state preferences are divided. Norms with overwhelming support need no institutional facilitation; they will emerge regardless. Norms with negligible support will not emerge regardless. The interesting cases are those in between, and the model identifies which structural factors push contested practices toward or away from crystallisation. Institutional design should be calibrated to the underlying preference landscape: a treaty channel is transformative for a practice with moderate support but superfluous for one with strong support; the persistent objector rule is devastating for fragile norms but tolerable for robust ones.</p>

                <p>The model is deliberately stylised. It simulates a single norm with static networks and unitary states; its parameters are theoretically motivated rather than empirically calibrated. These limitations define an agenda: norm competition, dynamic networks, domestic politics, empirical validation against historical episodes.</p>

                <p>But even within these constraints, the model demonstrates something that doctrinal analysis alone cannot: the ILC's two-element test describes a genuine dynamic process with identifiable mechanisms. Practice and <em>opinio juris</em> evolve at different rates, can decouple, and exhibit tipping-point dynamics. Observation structure is a hidden variable that shapes whether norms form. Cheap talk bootstraps the very conviction it initially lacks. Treaties catalyse custom among non-parties through indirect observation effects. And the persistent objector rule, rather than destabilising the system, filters out fragile norms while permitting robust ones to bind.</p>

                <p>Custom is not merely found; it is <em>made</em> &ndash; through observation, feedback, and the accumulation of practice and belief across a decentralised system of states. Understanding how it is made requires understanding the boundary dynamics where structural factors determine whether emerging practices crystallise into binding law or dissipate into mere behaviour.</p>

                <p style="margin-top: 2.5rem; padding-top: 1.5rem; border-top: 1px solid var(--border-color); font-size: 0.88rem; color: var(--secondary-color);">
                    <strong>Full paper:</strong> Niccolò Ridi, 'Custom in the Making: An Agent-Based Model of Customary International Law Formation' (2026).
                    <strong>Code:</strong> <a href="https://github.com/niccoloridi/PraxisBeliefABM" target="_blank">github.com/niccoloridi/PraxisBeliefABM</a>.
                </p>

            </div>

        </article>
    </main>

    <footer class="main-footer">
        <p><a href="mailto:niccolo.ridi@kcl.ac.uk">niccolo.ridi@kcl.ac.uk</a> &nbsp;|&nbsp; &copy; 2026 Niccolò Ridi. All Rights Reserved (probably).</p>
    </footer>

    <script>
    /* ── DATA ─────────────────────────────────────────── */

    // Heatmap: crystallisation rate by IP × CW
    const heatmapData = {
        ipValues: [0.15, 0.20, 0.25, 0.30, 0.35, 0.40, 0.45],
        cwValues: [0.20, 0.25, 0.30, 0.35, 0.40, 0.45, 0.50, 0.55, 0.60],
        rates: [
            [0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0.25],
            [0,0,0,0,0.12,0.50,0.75,0.88,1.00],
            [0,0.25,0.75,0.88,1.00,1.00,1.00,1.00,1.00],
            [1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00],
            [1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00]
        ]
    };

    // Mean crystallisation time (where crystallised)
    const heatmapTime = {
        rates: [
            [null,null,null,null,null,null,null,null,null],
            [null,null,null,null,null,null,null,null,null],
            [null,null,null,null,null,null,null,178,null],
            [null,null,null,null,180,177,171,155,139],
            [null,194,182,172,157,138,116,99,82],
            [169,153,137,119,100,86,70,54,40],
            [115,98,87,73,60,47,37,27,22]
        ]
    };

    // Network topology results
    const topoData = [
        { name: "Complete", rate: 33, time: 186, practice: 0.606, oj: 0.711, spread: 0.253, color: '--topo-complete',
          desc: "All observe all equally" },
        { name: "Regional Clusters", rate: 46, time: 168, practice: 0.643, oj: 0.787, spread: 0.243, color: '--topo-regional',
          desc: "Dense intra-regional ties" },
        { name: "Small World", rate: 58, time: 167, practice: 0.631, oj: 0.791, spread: 0.223, color: '--topo-smallworld',
          desc: "Local clusters + bridging ties" },
        { name: "Scale-Free", rate: 52, time: 159, practice: 0.624, oj: 0.785, spread: 0.246, color: '--topo-scalefree',
          desc: "Hub-dominated structure" },
        { name: "Power-Weighted", rate: 49, time: 154, practice: 0.636, oj: 0.790, spread: 0.247, color: '--topo-power',
          desc: "Connections weighted by power" }
    ];

    // Sincerity experiment
    const sincerityData = [
        { sincerity: 0.2, crystRate: 44, stmtOJGap: 0.001, falseAffirm: 0.000, hollowPract: 0.000, meanOJ: 0.727 },
        { sincerity: 0.4, crystRate: 46, stmtOJGap: 0.031, falseAffirm: 0.000, hollowPract: 0.000, meanOJ: 0.743 },
        { sincerity: 0.6, crystRate: 48, stmtOJGap: 0.083, falseAffirm: 0.001, hollowPract: 0.002, meanOJ: 0.764 },
        { sincerity: 0.8, crystRate: 38, stmtOJGap: 0.033, falseAffirm: 0.020, hollowPract: 0.102, meanOJ: 0.715 },
        { sincerity: 1.0, crystRate: 6, stmtOJGap: -0.278, falseAffirm: 0.015, hollowPract: 0.377, meanOJ: 0.529 }
    ];

    // Structural factors comparison
    const structuralData = [
        { mechanism: "Baseline", boundary: 38, favourable: 100 },
        { mechanism: "Network\n(Small World)", boundary: 58, favourable: null },
        { mechanism: "Power\n(pro-aligned)", boundary: 80, favourable: null },
        { mechanism: "Power\n(anti-aligned)", boundary: 2, favourable: null },
        { mechanism: "Objection", boundary: 4, favourable: 90 },
        { mechanism: "Treaty", boundary: 100, favourable: 100 }
    ];

    // Speed-stability data
    const speedData = [
        { cw: 0.40, nCryst: 7, time: 194, preShockOJ: 0.812, survival: 86 },
        { cw: 0.45, nCryst: 19, time: 183, preShockOJ: 0.815, survival: 95 },
        { cw: 0.50, nCryst: 35, time: 179, preShockOJ: 0.832, survival: 100 },
        { cw: 0.55, nCryst: 46, time: 164, preShockOJ: 0.843, survival: 100 },
        { cw: 0.60, nCryst: 49, time: 145, preShockOJ: 0.862, survival: 100 }
    ];

    function css(v) { return getComputedStyle(document.documentElement).getPropertyValue(v).trim(); }

    /* ── HEATMAP ─────────────────────────────────── */
    function drawHeatmap() {
        const container = d3.select("#viz-heatmap");
        container.selectAll("*").remove();
        const w = container.node().getBoundingClientRect().width;
        const h = Math.min(400, w * 0.65);
        const m = { top: 30, right: 60, bottom: 55, left: 70 };

        const svg = container.append("svg")
            .attr("width", w).attr("height", h)
            .attr("viewBox", `0 0 ${w} ${h}`);

        const ip = heatmapData.ipValues;
        const cw = heatmapData.cwValues;

        const cellW = (w - m.left - m.right) / cw.length;
        const cellH = (h - m.top - m.bottom) / ip.length;

        // Color scale
        const colorScale = d3.scaleSequential()
            .domain([0, 1])
            .interpolator(t => d3.interpolateRgb(css('--heat-low'), css('--heat-high'))(t));

        // Tooltip
        const tooltip = container.append("div").attr("class", "viz-tooltip");

        // Cells
        ip.forEach((ipVal, i) => {
            cw.forEach((cwVal, j) => {
                const rate = heatmapData.rates[i][j];
                const time = heatmapTime.rates[i][j];
                svg.append("rect")
                    .attr("class", "heat-cell")
                    .attr("x", m.left + j * cellW)
                    .attr("y", m.top + i * cellH)
                    .attr("width", cellW - 1)
                    .attr("height", cellH - 1)
                    .attr("fill", colorScale(rate))
                    .attr("rx", 2)
                    .on("mousemove", function(event) {
                        let txt = `µ_IP = ${ipVal}, µ_CW = ${cwVal}<br>Crystallisation: <strong>${Math.round(rate * 100)}%</strong>`;
                        if (time !== null) txt += `<br>Mean time: ${time} steps`;
                        tooltip.html(txt)
                            .style("left", (event.offsetX + 12) + "px")
                            .style("top", (event.offsetY - 10) + "px")
                            .style("opacity", 1);
                    })
                    .on("mouseleave", () => tooltip.style("opacity", 0));

                // Cell label
                svg.append("text")
                    .attr("x", m.left + j * cellW + cellW / 2)
                    .attr("y", m.top + i * cellH + cellH / 2)
                    .attr("dy", "0.35em")
                    .attr("text-anchor", "middle")
                    .attr("font-size", cellW > 50 ? "11px" : "9px")
                    .attr("font-weight", "600")
                    .attr("fill", rate > 0.5 ? "#fff" : css('--text-color'))
                    .attr("pointer-events", "none")
                    .text(Math.round(rate * 100) + "%");
            });
        });

        // Y axis labels (IP)
        ip.forEach((val, i) => {
            svg.append("text")
                .attr("x", m.left - 8)
                .attr("y", m.top + i * cellH + cellH / 2)
                .attr("dy", "0.35em")
                .attr("text-anchor", "end")
                .attr("font-size", "10px")
                .attr("fill", css('--secondary-color'))
                .text(val.toFixed(2));
        });

        // X axis labels (CW)
        cw.forEach((val, j) => {
            svg.append("text")
                .attr("x", m.left + j * cellW + cellW / 2)
                .attr("y", h - m.bottom + 16)
                .attr("text-anchor", "middle")
                .attr("font-size", "10px")
                .attr("fill", css('--secondary-color'))
                .text(val.toFixed(2));
        });

        // Axis titles
        svg.append("text")
            .attr("x", (m.left + w - m.right) / 2)
            .attr("y", h - 8)
            .attr("text-anchor", "middle")
            .attr("font-size", "11px")
            .attr("fill", css('--secondary-color'))
            .text("Conformity Weight Mean (µ_CW)");

        svg.append("text")
            .attr("transform", `rotate(-90)`)
            .attr("x", -(m.top + h - m.bottom) / 2)
            .attr("y", 14)
            .attr("text-anchor", "middle")
            .attr("font-size", "11px")
            .attr("fill", css('--secondary-color'))
            .text("Intrinsic Preference Mean (µ_IP)");

        // Color legend
        const legendW = 15;
        const legendH = h - m.top - m.bottom;
        const legendX = w - m.right + 20;
        const defs = svg.append("defs");
        const grad = defs.append("linearGradient").attr("id", "heat-grad").attr("x1", "0").attr("y1", "1").attr("x2", "0").attr("y2", "0");
        grad.append("stop").attr("offset", "0%").attr("stop-color", css('--heat-low'));
        grad.append("stop").attr("offset", "100%").attr("stop-color", css('--heat-high'));
        svg.append("rect").attr("x", legendX).attr("y", m.top).attr("width", legendW).attr("height", legendH).attr("fill", "url(#heat-grad)").attr("rx", 2);
        [0, 0.25, 0.5, 0.75, 1.0].forEach(v => {
            svg.append("text")
                .attr("x", legendX + legendW + 5)
                .attr("y", m.top + legendH * (1 - v))
                .attr("dy", "0.35em")
                .attr("font-size", "9px")
                .attr("fill", css('--secondary-color'))
                .text(Math.round(v * 100) + "%");
        });
    }

    /* ── MINI NETWORK TOPOLOGIES ─────────────────── */
    function drawTopologies() {
        const container = d3.select("#viz-topologies");
        container.selectAll("*").remove();
        const grid = container.append("div").attr("class", "topo-grid");

        topoData.forEach(topo => {
            const card = grid.append("div").attr("class", "topo-card");
            card.append("div").attr("class", "topo-label").text(topo.name);

            const size = 130;
            const svg = card.append("svg").attr("width", size).attr("height", size).attr("viewBox", `0 0 ${size} ${size}`);

            // Generate mini network
            const N = 20;
            const nodes = d3.range(N).map(i => ({
                id: i,
                region: Math.floor(i / 4),
                x: size / 2 + (Math.random() - 0.5) * size * 0.6,
                y: size / 2 + (Math.random() - 0.5) * size * 0.6
            }));
            const links = [];

            if (topo.name === "Complete") {
                for (let i = 0; i < N; i++)
                    for (let j = i + 1; j < N; j++)
                        links.push({ source: i, target: j });
            } else if (topo.name === "Regional Clusters") {
                for (let i = 0; i < N; i++)
                    for (let j = i + 1; j < N; j++) {
                        if (nodes[i].region === nodes[j].region && Math.random() < 0.6) links.push({ source: i, target: j });
                        else if (Math.random() < 0.03) links.push({ source: i, target: j });
                    }
            } else if (topo.name === "Small World") {
                for (let i = 0; i < N; i++) {
                    for (let k = 1; k <= 2; k++) {
                        links.push({ source: i, target: (i + k) % N });
                    }
                    if (Math.random() < 0.15) links.push({ source: i, target: Math.floor(Math.random() * N) });
                }
            } else if (topo.name === "Scale-Free") {
                const degree = new Array(N).fill(0);
                for (let i = 1; i < N; i++) {
                    const targets = new Set();
                    while (targets.size < Math.min(2, i)) {
                        const totalDeg = degree.reduce((a, b) => a + b, 0) || 1;
                        let r = Math.random() * totalDeg;
                        for (let j = 0; j < i; j++) {
                            r -= (degree[j] || 1);
                            if (r <= 0) { targets.add(j); break; }
                        }
                    }
                    targets.forEach(t => {
                        links.push({ source: i, target: t });
                        degree[i]++;
                        degree[t]++;
                    });
                }
            } else {
                // Power-weighted
                for (let i = 0; i < N; i++)
                    for (let j = i + 1; j < N; j++) {
                        const pi = 1 / (i + 1);
                        const pj = 1 / (j + 1);
                        if (Math.random() < pi * pj * 8) links.push({ source: i, target: j });
                    }
            }

            const col = css(topo.color);

            // Force simulation (static)
            const sim = d3.forceSimulation(nodes)
                .force("link", d3.forceLink(links).id(d => d.id).distance(20))
                .force("charge", d3.forceManyBody().strength(-15))
                .force("center", d3.forceCenter(size / 2, size / 2))
                .force("collision", d3.forceCollide(6))
                .stop();

            for (let i = 0; i < 80; i++) sim.tick();

            nodes.forEach(d => {
                d.x = Math.max(8, Math.min(size - 8, d.x));
                d.y = Math.max(8, Math.min(size - 8, d.y));
            });

            const isComplete = topo.name === "Complete";
            svg.selectAll("line").data(links).join("line")
                .attr("x1", d => d.source.x).attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x).attr("y2", d => d.target.y)
                .attr("stroke", col)
                .attr("stroke-opacity", isComplete ? 0.12 : 0.3)
                .attr("stroke-width", isComplete ? 0.4 : 0.8);

            svg.selectAll("circle").data(nodes).join("circle")
                .attr("cx", d => d.x).attr("cy", d => d.y)
                .attr("r", (d, i) => i === 0 ? 4 : 2.5)
                .attr("fill", col).attr("opacity", 0.7);

            card.append("div").attr("class", "topo-rate").text(topo.rate + "%");
            card.append("div").attr("class", "topo-sub").text("crystallisation");
        });
    }

    /* ── TOPOLOGY BAR CHART ──────────────────────── */
    function drawTopoBars() {
        const container = d3.select("#viz-topo-bars");
        container.selectAll("*").remove();
        const w = container.node().getBoundingClientRect().width;
        const h = Math.min(300, w * 0.5);
        const m = { top: 20, right: 30, bottom: 60, left: 50 };

        const svg = container.append("svg")
            .attr("width", w).attr("height", h)
            .attr("viewBox", `0 0 ${w} ${h}`);

        const x = d3.scaleBand()
            .domain(topoData.map(d => d.name))
            .range([m.left, w - m.right])
            .padding(0.25);

        const y = d3.scaleLinear()
            .domain([0, 70])
            .range([h - m.bottom, m.top]);

        // Grid lines
        [10, 20, 30, 40, 50, 60].forEach(v => {
            svg.append("line")
                .attr("x1", m.left).attr("x2", w - m.right)
                .attr("y1", y(v)).attr("y2", y(v))
                .attr("stroke", css('--border-color'))
                .attr("stroke-dasharray", "2,2")
                .attr("opacity", 0.5);
        });

        // Baseline line
        svg.append("line")
            .attr("x1", m.left).attr("x2", w - m.right)
            .attr("y1", y(33)).attr("y2", y(33))
            .attr("stroke", css('--stat-color'))
            .attr("stroke-dasharray", "6,3")
            .attr("stroke-width", 1.5)
            .attr("opacity", 0.6);

        svg.append("text")
            .attr("x", w - m.right + 3).attr("y", y(33))
            .attr("dy", "0.35em")
            .attr("font-size", "9px")
            .attr("fill", css('--stat-color'))
            .text("baseline");

        // Bars
        const tooltip = container.append("div").attr("class", "viz-tooltip");

        svg.selectAll(".bar")
            .data(topoData)
            .join("rect")
            .attr("x", d => x(d.name))
            .attr("y", d => y(d.rate))
            .attr("width", x.bandwidth())
            .attr("height", d => y(0) - y(d.rate))
            .attr("fill", d => css(d.color))
            .attr("rx", 3)
            .attr("opacity", 0.85)
            .on("mousemove", function(event, d) {
                tooltip.html(`<strong>${d.name}</strong><br>Rate: ${d.rate}%<br>Time: ${d.time} steps<br>Final OJ: ${d.oj}<br>Spread: ${d.spread}`)
                    .style("left", (event.offsetX + 12) + "px")
                    .style("top", (event.offsetY - 10) + "px")
                    .style("opacity", 1);
            })
            .on("mouseleave", () => tooltip.style("opacity", 0));

        // Value labels
        svg.selectAll(".bar-val")
            .data(topoData)
            .join("text")
            .attr("x", d => x(d.name) + x.bandwidth() / 2)
            .attr("y", d => y(d.rate) - 6)
            .attr("text-anchor", "middle")
            .attr("font-size", "11px")
            .attr("font-weight", "700")
            .attr("fill", css('--primary-color'))
            .text(d => d.rate + "%");

        // X axis
        svg.append("g")
            .attr("transform", `translate(0,${h - m.bottom})`)
            .call(d3.axisBottom(x).tickSize(0))
            .attr("class", "bar-axis")
            .selectAll("text")
            .attr("fill", css('--secondary-color'))
            .attr("font-size", "9px")
            .attr("transform", "rotate(-25)")
            .attr("text-anchor", "end")
            .attr("dx", "-0.3em")
            .attr("dy", "0.8em");

        svg.select(".bar-axis path").attr("stroke", css('--border-color'));

        // Y axis
        svg.append("g")
            .attr("transform", `translate(${m.left},0)`)
            .call(d3.axisLeft(y).ticks(4).tickFormat(d => d + "%").tickSize(-w + m.left + m.right))
            .attr("class", "bar-axis")
            .selectAll("line").attr("stroke", "none");

        svg.append("text")
            .attr("transform", "rotate(-90)")
            .attr("x", -(m.top + h - m.bottom) / 2)
            .attr("y", 12)
            .attr("text-anchor", "middle")
            .attr("font-size", "10px")
            .attr("fill", css('--secondary-color'))
            .text("Crystallisation Rate");
    }

    /* ── SINCERITY CHART ─────────────────────────── */
    function drawSincerity() {
        const container = d3.select("#viz-sincerity");
        container.selectAll("*").remove();
        const w = container.node().getBoundingClientRect().width;
        const h = Math.min(320, w * 0.55);
        const m = { top: 25, right: 50, bottom: 50, left: 50 };

        const svg = container.append("svg")
            .attr("width", w).attr("height", h)
            .attr("viewBox", `0 0 ${w} ${h}`);

        const x = d3.scaleBand()
            .domain(sincerityData.map(d => d.sincerity))
            .range([m.left, w - m.right])
            .padding(0.2);

        const yRate = d3.scaleLinear().domain([0, 55]).range([h - m.bottom, m.top]);
        const yOJ = d3.scaleLinear().domain([0.4, 0.85]).range([h - m.bottom, m.top]);

        const tooltip = container.append("div").attr("class", "viz-tooltip");

        // Grid
        [10, 20, 30, 40, 50].forEach(v => {
            svg.append("line")
                .attr("x1", m.left).attr("x2", w - m.right)
                .attr("y1", yRate(v)).attr("y2", yRate(v))
                .attr("stroke", css('--border-color'))
                .attr("stroke-dasharray", "2,2")
                .attr("opacity", 0.4);
        });

        // Bars (crystallisation rate)
        svg.selectAll(".sinc-bar")
            .data(sincerityData)
            .join("rect")
            .attr("x", d => x(d.sincerity))
            .attr("y", d => yRate(d.crystRate))
            .attr("width", x.bandwidth() * 0.6)
            .attr("height", d => yRate(0) - yRate(d.crystRate))
            .attr("fill", css('--bar-primary'))
            .attr("rx", 3)
            .attr("opacity", 0.85)
            .on("mousemove", function(event, d) {
                tooltip.html(`<strong>Sincerity = ${d.sincerity}</strong><br>Crystallisation: ${d.crystRate}%<br>Mean OJ: ${d.meanOJ}<br>Stmt-OJ gap: ${d.stmtOJGap > 0 ? '+' : ''}${d.stmtOJGap.toFixed(3)}<br>Hollow practitioners: ${(d.hollowPract * 100).toFixed(1)}%`)
                    .style("left", (event.offsetX + 12) + "px")
                    .style("top", (event.offsetY - 10) + "px")
                    .style("opacity", 1);
            })
            .on("mouseleave", () => tooltip.style("opacity", 0));

        // Rate labels
        svg.selectAll(".sinc-label")
            .data(sincerityData)
            .join("text")
            .attr("x", d => x(d.sincerity) + x.bandwidth() * 0.3)
            .attr("y", d => yRate(d.crystRate) - 6)
            .attr("text-anchor", "middle")
            .attr("font-size", "11px")
            .attr("font-weight", "700")
            .attr("fill", css('--primary-color'))
            .text(d => d.crystRate + "%");

        // OJ line
        const ojLine = d3.line()
            .x(d => x(d.sincerity) + x.bandwidth() * 0.6 + x.bandwidth() * 0.15)
            .y(d => yOJ(d.meanOJ))
            .curve(d3.curveMonotoneX);

        svg.append("path")
            .datum(sincerityData)
            .attr("d", ojLine)
            .attr("fill", "none")
            .attr("stroke", css('--bar-secondary'))
            .attr("stroke-width", 2.5)
            .attr("stroke-dasharray", "6,3");

        svg.selectAll(".oj-dot")
            .data(sincerityData)
            .join("circle")
            .attr("cx", d => x(d.sincerity) + x.bandwidth() * 0.6 + x.bandwidth() * 0.15)
            .attr("cy", d => yOJ(d.meanOJ))
            .attr("r", 4)
            .attr("fill", css('--bar-secondary'));

        // X axis
        svg.append("g")
            .attr("transform", `translate(0,${h - m.bottom})`)
            .call(d3.axisBottom(x).tickSize(0))
            .attr("class", "bar-axis");

        svg.append("text")
            .attr("x", (m.left + w - m.right) / 2)
            .attr("y", h - 8)
            .attr("text-anchor", "middle")
            .attr("font-size", "11px")
            .attr("fill", css('--secondary-color'))
            .text("Sincerity Parameter");

        // Y axis left
        svg.append("g")
            .attr("transform", `translate(${m.left},0)`)
            .call(d3.axisLeft(yRate).ticks(5).tickFormat(d => d + "%").tickSize(3))
            .attr("class", "bar-axis");

        svg.append("text")
            .attr("transform", "rotate(-90)")
            .attr("x", -(m.top + h - m.bottom) / 2)
            .attr("y", 10)
            .attr("text-anchor", "middle")
            .attr("font-size", "10px")
            .attr("fill", css('--bar-primary'))
            .text("Crystallisation Rate");

        // Y axis right
        svg.append("g")
            .attr("transform", `translate(${w - m.right},0)`)
            .call(d3.axisRight(yOJ).ticks(4).tickSize(3))
            .attr("class", "bar-axis");

        svg.append("text")
            .attr("transform", "rotate(90)")
            .attr("x", (m.top + h - m.bottom) / 2)
            .attr("y", -w + m.right - 12)
            .attr("text-anchor", "middle")
            .attr("font-size", "10px")
            .attr("fill", css('--bar-secondary'))
            .text("Mean Opinio Juris");

        // Legend
        const leg = container.append("div").attr("class", "viz-legend");
        leg.append("span").html(`<span class="swatch" style="background:${css('--bar-primary')}"></span> Crystallisation rate`);
        leg.append("span").html(`<span class="swatch" style="background:${css('--bar-secondary')}"></span> Mean opinio juris`);
    }

    /* ── STRUCTURAL FACTORS ──────────────────────── */
    function drawStructural() {
        const container = d3.select("#viz-structural");
        container.selectAll("*").remove();
        const w = container.node().getBoundingClientRect().width;
        const h = Math.min(350, w * 0.55);
        const m = { top: 25, right: 20, bottom: 80, left: 50 };

        const svg = container.append("svg")
            .attr("width", w).attr("height", h)
            .attr("viewBox", `0 0 ${w} ${h}`);

        // Show boundary values as bars
        const data = [
            { label: "Baseline", val: 38, cat: "base" },
            { label: "Small World\nnetwork", val: 58, cat: "positive" },
            { label: "Power\npro-aligned", val: 80, cat: "positive" },
            { label: "Treaty\nchannel", val: 100, cat: "positive" },
            { label: "Persistent\nobjection", val: 4, cat: "negative" },
            { label: "Power\nanti-aligned", val: 2, cat: "negative" }
        ];

        const x = d3.scaleBand()
            .domain(data.map(d => d.label))
            .range([m.left, w - m.right])
            .padding(0.2);

        const y = d3.scaleLinear().domain([0, 105]).range([h - m.bottom, m.top]);

        const tooltip = container.append("div").attr("class", "viz-tooltip");

        // Grid
        [20, 40, 60, 80, 100].forEach(v => {
            svg.append("line")
                .attr("x1", m.left).attr("x2", w - m.right)
                .attr("y1", y(v)).attr("y2", y(v))
                .attr("stroke", css('--border-color'))
                .attr("stroke-dasharray", "2,2")
                .attr("opacity", 0.4);
        });

        // Baseline reference
        svg.append("line")
            .attr("x1", m.left).attr("x2", w - m.right)
            .attr("y1", y(38)).attr("y2", y(38))
            .attr("stroke", css('--stat-color'))
            .attr("stroke-dasharray", "6,3")
            .attr("stroke-width", 1.5)
            .attr("opacity", 0.5);

        // Bars
        const barColor = d => {
            if (d.cat === "base") return css('--secondary-color');
            if (d.cat === "positive") return css('--bar-tertiary');
            return css('--bar-danger');
        };

        svg.selectAll(".struct-bar")
            .data(data)
            .join("rect")
            .attr("x", d => x(d.label))
            .attr("y", d => y(d.val))
            .attr("width", x.bandwidth())
            .attr("height", d => y(0) - y(d.val))
            .attr("fill", barColor)
            .attr("rx", 3)
            .attr("opacity", 0.85);

        // Value labels
        svg.selectAll(".struct-val")
            .data(data)
            .join("text")
            .attr("x", d => x(d.label) + x.bandwidth() / 2)
            .attr("y", d => y(d.val) - 6)
            .attr("text-anchor", "middle")
            .attr("font-size", "12px")
            .attr("font-weight", "700")
            .attr("fill", css('--primary-color'))
            .text(d => d.val + "%");

        // X axis labels (multiline)
        data.forEach(d => {
            const lines = d.label.split("\n");
            const xPos = x(d.label) + x.bandwidth() / 2;
            lines.forEach((line, i) => {
                svg.append("text")
                    .attr("x", xPos)
                    .attr("y", h - m.bottom + 16 + i * 13)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "9px")
                    .attr("fill", css('--secondary-color'))
                    .text(line);
            });
        });

        // Y axis
        svg.append("g")
            .attr("transform", `translate(${m.left},0)`)
            .call(d3.axisLeft(y).ticks(5).tickFormat(d => d + "%").tickSize(3))
            .attr("class", "bar-axis");

        svg.append("text")
            .attr("transform", "rotate(-90)")
            .attr("x", -(m.top + h - m.bottom) / 2)
            .attr("y", 10)
            .attr("text-anchor", "middle")
            .attr("font-size", "10px")
            .attr("fill", css('--secondary-color'))
            .text("Crystallisation Rate (boundary)");

        // Legend
        const leg = container.append("div").attr("class", "viz-legend");
        leg.append("span").html(`<span class="swatch" style="background:${css('--bar-tertiary')}"></span> Facilitating`);
        leg.append("span").html(`<span class="swatch" style="background:${css('--bar-danger')}"></span> Inhibiting`);
        leg.append("span").html(`<span class="swatch" style="background:${css('--secondary-color')}"></span> Baseline (no mechanism)`);
    }

    /* ── SPEED-STABILITY TRADE-OFF ───────────────── */
    function drawSpeed() {
        const container = d3.select("#viz-speed");
        container.selectAll("*").remove();
        const w = container.node().getBoundingClientRect().width;
        const h = Math.min(300, w * 0.5);
        const m = { top: 25, right: 55, bottom: 50, left: 55 };

        const svg = container.append("svg")
            .attr("width", w).attr("height", h)
            .attr("viewBox", `0 0 ${w} ${h}`);

        const x = d3.scaleBand()
            .domain(speedData.map(d => d.cw))
            .range([m.left, w - m.right])
            .padding(0.2);

        const yTime = d3.scaleLinear().domain([100, 200]).range([h - m.bottom, m.top]);
        const ySurv = d3.scaleLinear().domain([80, 102]).range([h - m.bottom, m.top]);

        const tooltip = container.append("div").attr("class", "viz-tooltip");

        // Grid
        [120, 140, 160, 180, 200].forEach(v => {
            svg.append("line")
                .attr("x1", m.left).attr("x2", w - m.right)
                .attr("y1", yTime(v)).attr("y2", yTime(v))
                .attr("stroke", css('--border-color'))
                .attr("stroke-dasharray", "2,2")
                .attr("opacity", 0.4);
        });

        // Bars (crystallisation time)
        svg.selectAll(".speed-bar")
            .data(speedData)
            .join("rect")
            .attr("x", d => x(d.cw))
            .attr("y", d => yTime(d.time))
            .attr("width", x.bandwidth() * 0.6)
            .attr("height", d => yTime(100) - yTime(d.time))
            .attr("fill", css('--bar-primary'))
            .attr("rx", 3)
            .attr("opacity", 0.85)
            .on("mousemove", function(event, d) {
                tooltip.html(`<strong>CW = ${d.cw}</strong><br>Crystallised: ${d.nCryst}/50<br>Mean time: ${d.time} steps<br>Pre-shock OJ: ${d.preShockOJ}<br>Survival: ${d.survival}%`)
                    .style("left", (event.offsetX + 12) + "px")
                    .style("top", (event.offsetY - 10) + "px")
                    .style("opacity", 1);
            })
            .on("mouseleave", () => tooltip.style("opacity", 0));

        // Time labels
        svg.selectAll(".speed-label")
            .data(speedData)
            .join("text")
            .attr("x", d => x(d.cw) + x.bandwidth() * 0.3)
            .attr("y", d => yTime(d.time) - 6)
            .attr("text-anchor", "middle")
            .attr("font-size", "10px")
            .attr("font-weight", "700")
            .attr("fill", css('--primary-color'))
            .text(d => d.time);

        // Survival rate line
        const survLine = d3.line()
            .x(d => x(d.cw) + x.bandwidth() * 0.6 + x.bandwidth() * 0.15)
            .y(d => ySurv(d.survival))
            .curve(d3.curveMonotoneX);

        svg.append("path")
            .datum(speedData)
            .attr("d", survLine)
            .attr("fill", "none")
            .attr("stroke", css('--bar-tertiary'))
            .attr("stroke-width", 2.5)
            .attr("stroke-dasharray", "6,3");

        svg.selectAll(".surv-dot")
            .data(speedData)
            .join("circle")
            .attr("cx", d => x(d.cw) + x.bandwidth() * 0.6 + x.bandwidth() * 0.15)
            .attr("cy", d => ySurv(d.survival))
            .attr("r", 4)
            .attr("fill", css('--bar-tertiary'));

        // Survival labels
        svg.selectAll(".surv-label")
            .data(speedData)
            .join("text")
            .attr("x", d => x(d.cw) + x.bandwidth() * 0.6 + x.bandwidth() * 0.15)
            .attr("y", d => ySurv(d.survival) - 8)
            .attr("text-anchor", "middle")
            .attr("font-size", "9px")
            .attr("font-weight", "600")
            .attr("fill", css('--bar-tertiary'))
            .text(d => d.survival + "%");

        // X axis
        svg.append("g")
            .attr("transform", `translate(0,${h - m.bottom})`)
            .call(d3.axisBottom(x).tickSize(0))
            .attr("class", "bar-axis");

        svg.append("text")
            .attr("x", (m.left + w - m.right) / 2)
            .attr("y", h - 8)
            .attr("text-anchor", "middle")
            .attr("font-size", "11px")
            .attr("fill", css('--secondary-color'))
            .text("Conformity Weight");

        // Y axis left (time)
        svg.append("g")
            .attr("transform", `translate(${m.left},0)`)
            .call(d3.axisLeft(yTime).ticks(5).tickSize(3))
            .attr("class", "bar-axis");

        svg.append("text")
            .attr("transform", "rotate(-90)")
            .attr("x", -(m.top + h - m.bottom) / 2)
            .attr("y", 12)
            .attr("text-anchor", "middle")
            .attr("font-size", "10px")
            .attr("fill", css('--bar-primary'))
            .text("Mean Cryst. Time (steps)");

        // Y axis right (survival)
        svg.append("g")
            .attr("transform", `translate(${w - m.right},0)`)
            .call(d3.axisRight(ySurv).ticks(4).tickFormat(d => d + "%").tickSize(3))
            .attr("class", "bar-axis");

        svg.append("text")
            .attr("transform", "rotate(90)")
            .attr("x", (m.top + h - m.bottom) / 2)
            .attr("y", -w + m.right - 12)
            .attr("text-anchor", "middle")
            .attr("font-size", "10px")
            .attr("fill", css('--bar-tertiary'))
            .text("Survival Rate After Shock");

        // Legend
        const leg = container.append("div").attr("class", "viz-legend");
        leg.append("span").html(`<span class="swatch" style="background:${css('--bar-primary')}"></span> Mean crystallisation time`);
        leg.append("span").html(`<span class="swatch" style="background:${css('--bar-tertiary')}"></span> Norm survival rate`);
    }

    /* ── RENDER ALL ────────────────────────────────── */
    function renderAll() {
        drawHeatmap();
        drawTopologies();
        drawTopoBars();
        drawSincerity();
        drawSpeed();
        drawStructural();
    }

    renderAll();

    let resizeTimer;
    window.addEventListener('resize', () => {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(renderAll, 200);
    });

    /* ── SCROLL REVEAL ────────────────────────────── */
    const reveals = document.querySelectorAll('.viz-reveal');
    const revealObs = new IntersectionObserver((entries, obs) => {
        entries.forEach(entry => {
            if (entry.isIntersecting) { entry.target.classList.add('visible'); obs.unobserve(entry.target); }
        });
    }, { threshold: 0.1 });
    reveals.forEach(el => revealObs.observe(el));

    /* ── HAMBURGER ────────────────────────────────── */
    const hamburger = document.querySelector('.hamburger-menu');
    hamburger.addEventListener('click', () => document.body.classList.toggle('nav-open'));
    document.querySelectorAll('.main-nav a').forEach(link => {
        link.addEventListener('click', () => document.body.classList.remove('nav-open'));
    });

    /* ── THEME ────────────────────────────────────── */
    const icons = { light: '◑', dark: '◐' };
    const labels = { light: 'Light', dark: 'Dark' };
    function getDefaultTheme() { return 'dark'; }
    let currentTheme = localStorage.getItem('theme') || getDefaultTheme();
    function applyTheme(t) {
        document.body.classList.remove('dark-mode');
        document.documentElement.classList.remove('dark-mode');
        if (t === 'dark') { document.body.classList.add('dark-mode'); document.documentElement.classList.add('dark-mode'); }
        document.getElementById('theme-icon').textContent = icons[t];
        document.getElementById('theme-label').textContent = labels[t];
        localStorage.setItem('theme', t);
        currentTheme = t;
        renderAll();
    }
    function toggleTheme() {
        applyTheme(currentTheme === 'dark' ? 'light' : 'dark');
    }
    applyTheme(currentTheme);
    </script>

</body>
</html>
